<?xml version="1.0" encoding="UTF-8"?>
<Project name="ResQ-Capital">
    <Metadata>
        <Tagline>The "Arbitrage" Platform for Humanitarian Aid Allocation.</Tagline>
        <Objective>Identify underfunded global crises using Databricks and validate logistical/safety feasibility using computer vision and vector RAG.</Objective>
    </Metadata>

    <Architecture>
        <DesignPattern>Decoupled Micro-Module Architecture</DesignPattern>
        <Philosophy>
            Isolation of concerns via a 'Clean Architecture' approach. The system is split into three distinct layers: Data Engineering (Databricks), API Orchestration (FastAPI), and Reactive UI (Next.js). Each module within these layers must be functional, independently testable, and strictly typed.
        </Philosophy>
        
        <Orchestration>
            <Backend>FastAPI serves as the 'Intelligence Gateway,' managing asynchronous calls to Actian and Sphinx while serving pre-processed Databricks analytics.</Backend>
            <Frontend>Next.js (App Router) acts as the 'Operational Dashboard,' handling client-state, map rendering, and real-time safety flagging via SafetyKit.</Frontend>
        </Orchestration>

        <DataFlow>
            <Step order="1" phase="Ingestion" source="Databricks (pipeline.py)" destination="FastAPI /data store">
                Fetch ACAPS Severity and UN OCHA Funding. Perform math to produce the Neglect Index. Output is cached for API consumption.
            </Step>
            
            <Step order="2" phase="Validation" source="modules/context_engine.py + modules/vector.py (Actian)" trigger="On-Demand API Call">
                When a user selects a crisis or country, FastAPI triggers: (1) live Google News fetch for breaking news; (2) vector search in Actian for stored intel (GDACS, HDX, State Dept, HAPI); (3) LLM synthesis (OpenRouter) into an operational field briefing. Resulting briefing and risk context feed SafetyKit and the dashboard.
            </Step>

            <Step order="3" phase="Synthesis" source="modules/synthesis.py (Sphinx)" trigger="State Combination">
                Combine Neglect Score (Quantitative) and Safety Context (Qualitative). Sphinx generates a strategic deployment memo. 
            </Step>

            <Step order="4" phase="Presentation" source="FastAPI" destination="Next.js Frontend">
                Serve the finalized 'Investment Package' including the map coordinates, safety status, and the Sphinx-generated memo via a RESTful JSON response.
            </Step>
        </DataFlow>

        <CommunicationContract>
            RESTful API over HTTP. Next.js communicates with FastAPI using strictly defined Pydantic schemas shared across the backend to ensure frontend type-safety (via TypeScript interfaces).
        </CommunicationContract>
    </Architecture>

    <TechStack>
        <Track sponsor="Databricks" challenge="Geo-Insight">
            <Component>Core Engine: Data Ingestion (ACAPS/FTS) and Mismatch Math (PySpark/Python)</Component>
            <Integration>Exports prioritized crisis data to FastAPI backend via JSON/Data Lake</Integration>
        </Track>

        <Track sponsor="Actian" challenge="VectorAI">
            <Component>Safety RAG: Contextual Risk Analysis (VectorAI)</Component>
            <Integration>Layer 3 Context Engine: ingests GDACS, HDX, US State Dept, HDX HAPI, and Google News; chunks and embeds via OpenRouter; stores in Actian (with auto-recovery on collection corruption); retrieves plus city-specific and nearby-GDACS live data; synthesizes operational field briefings via OpenRouter. Briefings include local situation when coordinates/city are given.</Integration>
        </Track>

        <Track sponsor="Sphinx" challenge="Unique Application">
            <Component>Intelligence: LLM-powered Strategic Memo Generation</Component>
            <Integration>Synthesizes Databricks math and Actian text into actionable deployment plans</Integration>
        </Track>

        <Track sponsor="SafetyKit" challenge="Human Safety">
            <Component>Safety Layer: Automated Risk Filtering and Guardrails</Component>
            <Integration>Enforces 'No-Deploy' zones in the UI based on Actian security risk scores</Integration>
        </Track>

        <Layer3 name="Context Engine â€” Operational Intelligence">
            <DataSources>
                <Source name="GDACS">Natural disaster alerts (RSS); filtered by country and severity (Orange/Red for display).</Source>
                <Source name="HDX CKAN">Humanitarian dataset metadata; filtered by ISO3 country group (fq=groups:xxx) for accurate country scope.</Source>
                <Source name="US State Dept">Travel advisories and CountryTravelInformation (safety, health, transport); no auth.</Source>
                <Source name="HDX HAPI">Structured data: conflict events (ACLED), food security (IPC); app_identifier required, no API key.</Source>
                <Source name="Google News RSS">Breaking news (last 7 days); always fetched live at report time; no auth.</Source>
            </DataSources>
            <Output>Operational field briefing for humanitarian workers: What Changed This Week, Operating Environment, Key Risks, Operational Recommendations. Synthesized via OpenRouter from retrieved chunks and live news. ReliefWeb not used (requires pre-approved app name).</Output>
        </Layer3>

        <Track category="Backend Framework">
            <Component>FastAPI (Python 3.13)</Component>
            <Role>The Orchestrator: Manages API routing, data schemas (Pydantic), and serves as the bridge between AI modules and the UI</Role>
        </Track>

        <Track category="Frontend Framework">
            <Component>Next.js (React / TypeScript / Tailwind CSS)</Component>
            <Role>The Dashboard: Visualizes the 'Neglect Map' using Mapbox/Leaflet and provides the interface for 'Investment Memos'</Role>
        </Track>
    </TechStack>

    <RepositoryStructure>
        <Folder name="resq-capital">
            <Folder name="data">
                <Description>Shared JSON/CSV outputs</Description>
            </Folder>
            <Folder name="modules">
                <File name="pipeline.py">P1: ACAPS/FTS Data Engineering</File>
                <File name="crisis_query.py">Layer 3: City-level operational crises query via OpenRouter</File>
                <File name="candidate_verification.py">Layer 2: OSM candidate finder + Esri satellite ground validation via Ollama VLM</File>
                <File name="ground_verifier.py">Layer 2: Local Ollama analysis (llava vs satellite tiles) and Esri fetches</File>
                <File name="image_annotator.py">Layer 2: CV logic to draw bounding boxes and text directly on satellite images</File>
                <File name="osm_finder.py">Layer 2: Queries OpenStreetMap (osmnx) for nearby aid-receivable locations</File>
                <File name="osm_features.py">Layer 2: Advanced OSM feature parsing</File>
                <File name="vision.py">P2: Satellite CV logic (legacy stub)</File>
                <File name="vector.py">P2: Delegates safety report to context_engine</File>
                <File name="context_engine.py">Layer 3: Data ingest (GDACS, HDX CKAN/HAPI, US State Dept, Google News), chunking, OpenRouter embeddings, Actian store (auto-recovery), RAG + city/nearby live data, OpenRouter synthesis for operational briefings</File>
                <File name="synthesis.py">P3: Sphinx Prompting</File>
            </Folder>
            <Folder name="static">
                <File name="test.html">Layer 3 test UI: country search, ingest, get safety report</File>
            </Folder>
            <File name="app.py">FastAPI entry point; serves /, /test, /docs-simple, mounts /api/v1</File>
            <File name=".env">Secrets and API Keys</File>
            <File name="requirements.txt">Shared dependencies</File>
        </Folder>
    </RepositoryStructure>

    <TeamRoles>
        <Role id="P1" title="Data Engineer">
            <AssignedTo>Person 1</AssignedTo>
            <OutputTarget>data/neglect_scores.json</OutputTarget>
            <DataContract format="JSON">
                <![CDATA[
                {
                  "crisis_id": "str",
                  "country": "str",
                  "coordinates": {"lat": 0.0, "lng": 0.0},
                  "neglect_score": 0.0,
                  "severity": 0,
                  "funding_gap_usd": 0
                }
                ]]>
            </DataContract>
        </Role>
        <Role id="P2" title="AI Specialist">
            <AssignedTo>Person 2</AssignedTo>
            <Functions>
                <Function name="find_aid_sites">Finds candidate staging areas via OpenStreetMap, fetches satellite imagery, runs Ollama vision analysis to verify viability.</Function>
                <Function name="get_safety_report">Returns text summary via Actian and context_engine.</Function>
            </Functions>
        </Role>
        <Role id="P3" title="Product Architect">
            <AssignedTo>Person 3</AssignedTo>
            <Functions>
                <Function name="generate_memo">Calls Sphinx with aggregated data.</Function>
                <Function name="ui_logic">Map visualization via Folium/Streamlit.</Function>
            </Functions>
        </Role>
    </TeamRoles>

    <StrategicGuardrails>
        <Guardrail id="1" name="Zero-Inference Policy">
            <Statement>Do not assume safety or feasibility on missing data.</Statement>
            <Logic>If Actian VectorAI returns "No data found" for a high-severity region, the system must default to a 'Caution' state rather than 'Safe'. This prevents the AI from hallucinating safety in a data vacuum.</Logic>
        </Guardrail>

        <Guardrail id="2" name="Modular Dependency Isolation">
            <Statement>The API entry point (app.py) must remain logic-agnostic.</Statement>
            <Logic>All heavy lifting (math, RAG, prompt engineering) stays inside the /modules/ directory. app.py only handles HTTP orchestration. This ensures Person 3 can refactor the API without breaking Person 1's Databricks logic.</Logic>
        </Guardrail>

        <Guardrail id="3" name="Stability via State Mocking">
            <Statement>Maintain 'Demo-Ready' state through API fallbacks.</Statement>
            <Logic>Wrap every external API call (Sphinx, Actian) in a try-except block that returns a local 'Mock JSON' if the service is down or rate-limited. The frontend must never show a 500 error during the pitch.</Logic>
        </Guardrail>

        <Guardrail id="4" name="Conflict-Aware Filtering">
            <Statement>Trigger SafetyKit 'Hard-Stop' on high-risk vectors.</Statement>
            <Logic>If Actian identifies active combat or infrastructure collapse, the SafetyKit layer must programmatically disable the 'Allocate Funds' button in Next.js, regardless of how high the Databricks Neglect Score is. Safety over Arbitrage.</Logic>
        </Guardrail>

        <Guardrail id="5" name="Schema-First Development">
            <Statement>No logic changes without a Pydantic Schema update.</Statement>
            <Logic>If Person 1 changes the Databricks output format, they must update api/schemas.py first. This allows Cursor to immediately flag broken code in the Next.js frontend or the Synthesis module.</Logic>
        </Guardrail>
    </StrategicGuardrails>
</Project>